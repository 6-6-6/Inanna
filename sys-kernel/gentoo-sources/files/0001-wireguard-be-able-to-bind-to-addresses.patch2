diff -Nur a/drivers/net/wireguard/device.c b/drivers/net/wireguard/device.c
--- a/drivers/net/wireguard/device.c	2020-06-01 07:49:15.000000000 +0800
+++ b/drivers/net/wireguard/device.c	2020-07-13 18:10:39.620343921 +0800
@@ -45,7 +45,7 @@
 	if (dev_v6)
 		dev_v6->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_NONE;
 
-	ret = wg_socket_init(wg, wg->incoming_port);
+	ret = wg_socket_init(wg, &wg->bind_addr, wg->incoming_port);
 	if (ret < 0)
 		return ret;
 	mutex_lock(&wg->device_update_lock);
@@ -226,6 +226,7 @@
 	rtnl_unlock();
 	mutex_lock(&wg->device_update_lock);
 	wg->incoming_port = 0;
+	memset(&wg->bind_addr.addr, 0, sizeof(struct addr_struct));
 	wg_socket_reinit(wg, NULL, NULL);
 	/* The final references are cleared in the below calls to destroy_workqueue. */
 	wg_peer_remove_all(wg);
@@ -301,6 +302,7 @@
 	wg_cookie_checker_init(&wg->cookie_checker, wg);
 	INIT_LIST_HEAD(&wg->peer_list);
 	wg->device_update_gen = 1;
+	memset(&wg->bind_addr, 0, sizeof(struct addr_struct));
 
 	wg->peer_hashtable = wg_pubkey_hashtable_alloc();
 	if (!wg->peer_hashtable)
diff -Nur a/drivers/net/wireguard/device.h b/drivers/net/wireguard/device.h
--- a/drivers/net/wireguard/device.h	2020-06-01 07:49:15.000000000 +0800
+++ b/drivers/net/wireguard/device.h	2020-07-13 18:12:04.971353758 +0800
@@ -36,6 +36,14 @@
 	};
 };
 
+struct addr_struct {
+	union {
+		struct sockaddr addr;
+		struct sockaddr_in addr4;
+		struct sockaddr_in6 addr6;
+	};
+};
+
 struct wg_device {
 	struct net_device *dev;
 	struct crypt_queue encrypt_queue, decrypt_queue;
@@ -57,6 +65,7 @@
 	u32 fwmark;
 	u16 incoming_port;
 	bool have_creating_net_ref;
+	struct addr_struct bind_addr;
 };
 
 int wg_device_init(void);
diff -Nur a/drivers/net/wireguard/netlink.c b/drivers/net/wireguard/netlink.c
--- a/drivers/net/wireguard/netlink.c	2020-06-01 07:49:15.000000000 +0800
+++ b/drivers/net/wireguard/netlink.c	2020-07-13 18:18:54.383400941 +0800
@@ -26,6 +26,7 @@
 	[WGDEVICE_A_PUBLIC_KEY]		= { .type = NLA_EXACT_LEN, .len = NOISE_PUBLIC_KEY_LEN },
 	[WGDEVICE_A_FLAGS]		= { .type = NLA_U32 },
 	[WGDEVICE_A_LISTEN_PORT]	= { .type = NLA_U16 },
+	[WGDEVICE_A_BIND_ADDR]		= { .type = NLA_BINARY, .len = sizeof(struct addr_struct) },
 	[WGDEVICE_A_FWMARK]		= { .type = NLA_U32 },
 	[WGDEVICE_A_PEERS]		= { .type = NLA_NESTED }
 };
@@ -236,6 +237,14 @@
 		    nla_put_string(skb, WGDEVICE_A_IFNAME, wg->dev->name))
 			goto out;
 
+		if (wg->bind_addr.addr.sa_family == AF_INET) {
+			if (nla_put(skb, WGDEVICE_A_BIND_ADDR, sizeof(struct sockaddr_in), &wg->bind_addr.addr4))
+				goto out;
+		} else if (wg->bind_addr.addr.sa_family == AF_INET6) {
+			if (nla_put(skb, WGDEVICE_A_BIND_ADDR, sizeof(struct sockaddr_in6), &wg->bind_addr.addr6))
+				goto out;
+		}
+
 		down_read(&wg->static_identity.lock);
 		if (wg->static_identity.has_identity) {
 			if (nla_put(skb, WGDEVICE_A_PRIVATE_KEY,
@@ -311,19 +320,12 @@
 	return 0;
 }
 
-static int set_port(struct wg_device *wg, u16 port)
+static int set_socket(struct wg_device *wg, struct addr_struct *bind_addr, u16 port)
 {
 	struct wg_peer *peer;
-
-	if (wg->incoming_port == port)
-		return 0;
 	list_for_each_entry(peer, &wg->peer_list, peer_list)
 		wg_socket_clear_peer_endpoint_src(peer);
-	if (!netif_running(wg->dev)) {
-		wg->incoming_port = port;
-		return 0;
-	}
-	return wg_socket_init(wg, port);
+	return wg_socket_init(wg, bind_addr, port);
 }
 
 static int set_allowedip(struct wg_peer *peer, struct nlattr **attrs)
@@ -491,11 +493,23 @@
 	return ret;
 }
 
+static bool bind_addr_eq(const struct sockaddr *a, const struct sockaddr *b)
+{
+	return (a->sa_family == AF_INET && b->sa_family == AF_INET &&
+		((struct sockaddr_in *)a)->sin_addr.s_addr == ((struct sockaddr_in *)b)->sin_addr.s_addr) ||
+		(a->sa_family == AF_INET6 && b->sa_family == AF_INET6 &&
+		ipv6_addr_equal(&((struct sockaddr_in6 *)a)->sin6_addr, &((struct sockaddr_in6 *)b)->sin6_addr)) ||
+		(a->sa_family == AF_UNSPEC && b->sa_family == AF_UNSPEC);
+}
+
 static int wg_set_device(struct sk_buff *skb, struct genl_info *info)
 {
 	struct wg_device *wg = lookup_interface(info->attrs, skb);
 	u32 flags = 0;
 	int ret;
+	bool if_set_socket = false;
+	u16 port_new;
+	struct addr_struct bind_addr_new;
 
 	if (IS_ERR(wg)) {
 		ret = PTR_ERR(wg);
@@ -505,17 +519,24 @@
 	rtnl_lock();
 	mutex_lock(&wg->device_update_lock);
 
+	port_new = wg->incoming_port;
+	bind_addr_new = wg->bind_addr;
+
 	if (info->attrs[WGDEVICE_A_FLAGS])
 		flags = nla_get_u32(info->attrs[WGDEVICE_A_FLAGS]);
 	ret = -EOPNOTSUPP;
 	if (flags & ~__WGDEVICE_F_ALL)
 		goto out;
 
-	ret = -EPERM;
-	if ((info->attrs[WGDEVICE_A_LISTEN_PORT] ||
-	     info->attrs[WGDEVICE_A_FWMARK]) &&
-	    !ns_capable(wg->creating_net->user_ns, CAP_NET_ADMIN))
-		goto out;
+	if (info->attrs[WGDEVICE_A_LISTEN_PORT] || info->attrs[WGDEVICE_A_BIND_ADDR] || info->attrs[WGDEVICE_A_FWMARK]) {
+		struct net *net;
+		rcu_read_lock();
+		net = rcu_dereference(wg->creating_net);
+		ret = !net || !ns_capable(net->user_ns, CAP_NET_ADMIN) ? -EPERM : 0;
+		rcu_read_unlock();
+		if (ret)
+			goto out;
+	}
 
 	++wg->device_update_gen;
 
@@ -528,8 +549,37 @@
 	}
 
 	if (info->attrs[WGDEVICE_A_LISTEN_PORT]) {
-		ret = set_port(wg,
-			nla_get_u16(info->attrs[WGDEVICE_A_LISTEN_PORT]));
+		u16 port = nla_get_u16(info->attrs[WGDEVICE_A_LISTEN_PORT]);
+		if (wg->incoming_port != port) {
+			if (!netif_running(wg->dev))
+				wg->incoming_port = port;
+			else{
+				if_set_socket = true;
+				port_new = port;
+			}
+		}
+	}
+
+	if (info->attrs[WGDEVICE_A_BIND_ADDR]) {
+		struct sockaddr *addr = nla_data(info->attrs[WGDEVICE_A_BIND_ADDR]);
+		if (!bind_addr_eq(&wg->bind_addr.addr, addr)) {
+			size_t len = nla_len(info->attrs[WGDEVICE_A_BIND_ADDR]);
+			if ((addr->sa_family == AF_INET && len == sizeof(struct sockaddr_in)) ||
+				((addr->sa_family == AF_INET6 || addr->sa_family == AF_UNSPEC) && len == sizeof(struct sockaddr_in6))) {
+					if (!netif_running(wg->dev)){
+						memcpy(&wg->bind_addr.addr, addr, len);
+					} else {
+						if_set_socket=true;
+						memcpy(&bind_addr_new, addr, len);
+					}
+				}
+			else
+				goto out;
+		}
+	}
+
+	if (if_set_socket) {
+		ret = set_socket(wg, &bind_addr_new, port_new);
 		if (ret)
 			goto out;
 	}
diff -Nur a/drivers/net/wireguard/socket.c b/drivers/net/wireguard/socket.c
--- a/drivers/net/wireguard/socket.c	2020-06-01 07:49:15.000000000 +0800
+++ b/drivers/net/wireguard/socket.c	2020-07-13 18:23:50.229435037 +0800
@@ -345,7 +345,7 @@
 	sk_set_memalloc(sock->sk);
 }
 
-int wg_socket_init(struct wg_device *wg, u16 port)
+int wg_socket_init(struct wg_device *wg, struct addr_struct *bind_addr, u16 port)
 {
 	int ret;
 	struct udp_tunnel_sock_cfg cfg = {
@@ -365,6 +365,7 @@
 	struct udp_port_cfg port6 = {
 		.family = AF_INET6,
 		.local_ip6 = IN6ADDR_ANY_INIT,
+		.local_udp_port = htons(port),
 		.use_udp6_tx_checksums = true,
 		.use_udp6_rx_checksums = true,
 		.ipv6_v6only = true
@@ -375,20 +376,23 @@
 retry:
 #endif
 
-	ret = udp_sock_create(wg->creating_net, &port4, &new4);
-	if (ret < 0) {
-		pr_err("%s: Could not create IPv4 socket\n", wg->dev->name);
-		return ret;
+	if (bind_addr->addr.sa_family == AF_INET || bind_addr->addr.sa_family == AF_UNSPEC) {
+		if(bind_addr->addr.sa_family == AF_INET) port4.local_ip = bind_addr->addr4.sin_addr;
+		ret = udp_sock_create(net, &port4, &new4);
+		if (ret < 0) {
+			pr_err("%s: Could not create IPv4 socket\n", wg->dev->name);
+			return ret;
+		}
+		set_sock_opts(new4);
+		setup_udp_tunnel_sock(net, new4, &cfg);
 	}
-	set_sock_opts(new4);
-	setup_udp_tunnel_sock(wg->creating_net, new4, &cfg);
 
 #if IS_ENABLED(CONFIG_IPV6)
-	if (ipv6_mod_enabled()) {
-		port6.local_udp_port = inet_sk(new4->sk)->inet_sport;
+	if (ipv6_mod_enabled() && (bind_addr->addr.sa_family == AF_INET6 || bind_addr->addr.sa_family == AF_UNSPEC)) {
+		if(bind_addr->addr.sa_family == AF_INET6) port6.local_ip6 = bind_addr->addr6.sin6_addr;
 		ret = udp_sock_create(wg->creating_net, &port6, &new6);
 		if (ret < 0) {
-			udp_tunnel_sock_release(new4);
+			if(new4) udp_tunnel_sock_release(new4);
 			if (ret == -EADDRINUSE && !port && retries++ < 100)
 				goto retry;
 			pr_err("%s: Could not create IPv6 socket\n",
@@ -400,7 +404,7 @@
 	}
 #endif
 
-	wg_socket_reinit(wg, new4->sk, new6 ? new6->sk : NULL);
+	wg_socket_reinit(wg, new4 ? new4->sk : NULL, new6 ? new6->sk : NULL);
 	return 0;
 }
 
@@ -416,8 +420,15 @@
 				lockdep_is_held(&wg->socket_update_lock));
 	rcu_assign_pointer(wg->sock4, new4);
 	rcu_assign_pointer(wg->sock6, new6);
-	if (new4)
+	if(new4) {
 		wg->incoming_port = ntohs(inet_sk(new4)->inet_sport);
+		wg->bind_addr.addr4.sin_addr.s_addr = inet_sk(new4)->inet_saddr;
+		wg->bind_addr.addr.sa_family = new6 ? AF_UNSPEC : AF_INET;
+	} else if (new6) {
+		wg->incoming_port = ntohs(inet_sk(new6)->inet_sport);
+		memcpy(&wg->bind_addr.addr6.sin6_addr, &inet6_sk(new6)->saddr, sizeof(struct in6_addr));
+		wg->bind_addr.addr.sa_family = AF_INET6;
+	}
 	mutex_unlock(&wg->socket_update_lock);
 	synchronize_rcu();
 	sock_free(old4);
diff -Nur a/drivers/net/wireguard/socket.h b/drivers/net/wireguard/socket.h
--- a/drivers/net/wireguard/socket.h	2020-06-01 07:49:15.000000000 +0800
+++ b/drivers/net/wireguard/socket.h	2020-07-13 18:10:07.312340198 +0800
@@ -11,7 +11,7 @@
 #include <linux/if_vlan.h>
 #include <linux/if_ether.h>
 
-int wg_socket_init(struct wg_device *wg, u16 port);
+int wg_socket_init(struct wg_device *wg, struct addr_struct *bind_addr, u16 port);
 void wg_socket_reinit(struct wg_device *wg, struct sock *new4,
 		      struct sock *new6);
 int wg_socket_send_buffer_to_peer(struct wg_peer *peer, void *data,
diff -Nur a/include/uapi/linux/wireguard.h b/include/uapi/linux/wireguard.h
--- a/include/uapi/linux/wireguard.h	2020-06-01 07:49:15.000000000 +0800
+++ b/include/uapi/linux/wireguard.h	2020-07-13 18:10:07.313340198 +0800
@@ -155,6 +155,7 @@
 	WGDEVICE_A_PUBLIC_KEY,
 	WGDEVICE_A_FLAGS,
 	WGDEVICE_A_LISTEN_PORT,
+	WGDEVICE_A_BIND_ADDR,
 	WGDEVICE_A_FWMARK,
 	WGDEVICE_A_PEERS,
 	__WGDEVICE_A_LAST
