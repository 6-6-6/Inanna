diff -Nur a/src/device.c b/src/device.c
--- a/src/device.c	2020-07-13 19:24:22.600618782 +0800
+++ b/src/device.c	2020-07-13 19:38:58.366719712 +0800
@@ -29,9 +29,7 @@
 static int wg_open(struct net_device *dev)
 {
 	struct in_device *dev_v4 = __in_dev_get_rtnl(dev);
-#ifndef COMPAT_CANNOT_USE_IN6_DEV_GET
 	struct inet6_dev *dev_v6 = __in6_dev_get(dev);
-#endif
 	struct wg_device *wg = netdev_priv(dev);
 	struct wg_peer *peer;
 	int ret;
@@ -44,17 +42,11 @@
 		IN_DEV_CONF_SET(dev_v4, SEND_REDIRECTS, false);
 		IPV4_DEVCONF_ALL(dev_net(dev), SEND_REDIRECTS) = false;
 	}
-#ifndef COMPAT_CANNOT_USE_IN6_DEV_GET
 	if (dev_v6)
-#ifndef COMPAT_CANNOT_USE_DEV_CNF
 		dev_v6->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_NONE;
-#else
-		dev_v6->addr_gen_mode = IN6_ADDR_GEN_MODE_NONE;
-#endif
-#endif
 
 	mutex_lock(&wg->device_update_lock);
-	ret = wg_socket_init(wg, wg->incoming_port);
+	ret = wg_socket_init(wg, &wg->bind_addr, wg->incoming_port);
 	if (ret < 0)
 		goto out;
 	list_for_each_entry(peer, &wg->peer_list, peer_list) {
@@ -236,6 +228,7 @@
 	mutex_lock(&wg->device_update_lock);
 	rcu_assign_pointer(wg->creating_net, NULL);
 	wg->incoming_port = 0;
+	memset(&wg->bind_addr.addr, 0, sizeof(struct addr_struct));
 	wg_socket_reinit(wg, NULL, NULL);
 	/* The final references are cleared in the below calls to destroy_workqueue. */
 	wg_peer_remove_all(wg);
@@ -276,19 +269,13 @@
 	dev->needed_tailroom = noise_encrypted_len(MESSAGE_PADDING_MULTIPLE);
 	dev->type = ARPHRD_NONE;
 	dev->flags = IFF_POINTOPOINT | IFF_NOARP;
-#ifndef COMPAT_CANNOT_USE_IFF_NO_QUEUE
 	dev->priv_flags |= IFF_NO_QUEUE;
-#else
-	dev->tx_queue_len = 0;
-#endif
 	dev->features |= NETIF_F_LLTX;
 	dev->features |= WG_NETDEV_FEATURES;
 	dev->hw_features |= WG_NETDEV_FEATURES;
 	dev->hw_enc_features |= WG_NETDEV_FEATURES;
 	dev->mtu = ETH_DATA_LEN - overhead;
-#ifndef COMPAT_CANNOT_USE_MAX_MTU
 	dev->max_mtu = round_down(INT_MAX, MESSAGE_PADDING_MULTIPLE) - overhead;
-#endif
 
 	SET_NETDEV_DEVTYPE(dev, &device_type);
 
@@ -315,6 +302,7 @@
 	wg_cookie_checker_init(&wg->cookie_checker, wg);
 	INIT_LIST_HEAD(&wg->peer_list);
 	wg->device_update_gen = 1;
+	memset(&wg->bind_addr, 0, sizeof(struct addr_struct));
 
 	wg->peer_hashtable = wg_pubkey_hashtable_alloc();
 	if (!wg->peer_hashtable)
diff -Nur a/src/device.h b/src/device.h
--- a/src/device.h	2020-07-13 19:24:22.600618782 +0800
+++ b/src/device.h	2020-07-13 19:39:09.694721017 +0800
@@ -36,6 +36,14 @@
 	};
 };
 
+struct addr_struct {
+	union {
+		struct sockaddr addr;
+		struct sockaddr_in addr4;
+		struct sockaddr_in6 addr6;
+	};
+};
+
 struct wg_device {
 	struct net_device *dev;
 	struct crypt_queue encrypt_queue, decrypt_queue;
@@ -56,6 +64,7 @@
 	unsigned int num_peers, device_update_gen;
 	u32 fwmark;
 	u16 incoming_port;
+	struct addr_struct bind_addr;
 };
 
 int wg_device_init(void);
diff -Nur a/src/netlink.c b/src/netlink.c
--- a/src/netlink.c	2020-07-13 19:24:22.600618782 +0800
+++ b/src/netlink.c	2020-07-13 19:53:49.752822441 +0800
@@ -9,7 +9,9 @@
 #include "socket.h"
 #include "queueing.h"
 #include "messages.h"
+
 #include "uapi/wireguard.h"
+
 #include <linux/if.h>
 #include <net/genetlink.h>
 #include <net/sock.h>
@@ -24,6 +26,7 @@
 	[WGDEVICE_A_PUBLIC_KEY]		= { .type = NLA_EXACT_LEN, .len = NOISE_PUBLIC_KEY_LEN },
 	[WGDEVICE_A_FLAGS]		= { .type = NLA_U32 },
 	[WGDEVICE_A_LISTEN_PORT]	= { .type = NLA_U16 },
+	[WGDEVICE_A_BIND_ADDR]		= { .type = NLA_BINARY, .len = sizeof(struct addr_struct) },
 	[WGDEVICE_A_FWMARK]		= { .type = NLA_U32 },
 	[WGDEVICE_A_PEERS]		= { .type = NLA_NESTED }
 };
@@ -234,6 +237,14 @@
 		    nla_put_string(skb, WGDEVICE_A_IFNAME, wg->dev->name))
 			goto out;
 
+		if (wg->bind_addr.addr.sa_family == AF_INET) {
+			if (nla_put(skb, WGDEVICE_A_BIND_ADDR, sizeof(struct sockaddr_in), &wg->bind_addr.addr4))
+				goto out;
+		} else if (wg->bind_addr.addr.sa_family == AF_INET6) {
+			if (nla_put(skb, WGDEVICE_A_BIND_ADDR, sizeof(struct sockaddr_in6), &wg->bind_addr.addr6))
+				goto out;
+		}
+
 		down_read(&wg->static_identity.lock);
 		if (wg->static_identity.has_identity) {
 			if (nla_put(skb, WGDEVICE_A_PRIVATE_KEY,
@@ -309,19 +320,12 @@
 	return 0;
 }
 
-static int set_port(struct wg_device *wg, u16 port)
+static int set_socket(struct wg_device *wg, struct addr_struct *bind_addr, u16 port)
 {
 	struct wg_peer *peer;
-
-	if (wg->incoming_port == port)
-		return 0;
 	list_for_each_entry(peer, &wg->peer_list, peer_list)
 		wg_socket_clear_peer_endpoint_src(peer);
-	if (!netif_running(wg->dev)) {
-		wg->incoming_port = port;
-		return 0;
-	}
-	return wg_socket_init(wg, port);
+	return wg_socket_init(wg, bind_addr, port);
 }
 
 static int set_allowedip(struct wg_peer *peer, struct nlattr **attrs)
@@ -489,11 +493,23 @@
 	return ret;
 }
 
+static bool bind_addr_eq(const struct sockaddr *a, const struct sockaddr *b)
+{
+	return (a->sa_family == AF_INET && b->sa_family == AF_INET &&
+		((struct sockaddr_in *)a)->sin_addr.s_addr == ((struct sockaddr_in *)b)->sin_addr.s_addr) ||
+		(a->sa_family == AF_INET6 && b->sa_family == AF_INET6 &&
+		ipv6_addr_equal(&((struct sockaddr_in6 *)a)->sin6_addr, &((struct sockaddr_in6 *)b)->sin6_addr)) ||
+		(a->sa_family == AF_UNSPEC && b->sa_family == AF_UNSPEC);
+}
+
 static int wg_set_device(struct sk_buff *skb, struct genl_info *info)
 {
 	struct wg_device *wg = lookup_interface(info->attrs, skb);
 	u32 flags = 0;
 	int ret;
+	bool if_set_socket = false;
+	u16 port_new;
+	struct addr_struct bind_addr_new;
 
 	if (IS_ERR(wg)) {
 		ret = PTR_ERR(wg);
@@ -503,13 +519,16 @@
 	rtnl_lock();
 	mutex_lock(&wg->device_update_lock);
 
+	port_new = wg->incoming_port;
+	bind_addr_new = wg->bind_addr;
+
 	if (info->attrs[WGDEVICE_A_FLAGS])
 		flags = nla_get_u32(info->attrs[WGDEVICE_A_FLAGS]);
 	ret = -EOPNOTSUPP;
 	if (flags & ~__WGDEVICE_F_ALL)
 		goto out;
 
-	if (info->attrs[WGDEVICE_A_LISTEN_PORT] || info->attrs[WGDEVICE_A_FWMARK]) {
+	if (info->attrs[WGDEVICE_A_LISTEN_PORT] || info->attrs[WGDEVICE_A_BIND_ADDR] || info->attrs[WGDEVICE_A_FWMARK]) {
 		struct net *net;
 		rcu_read_lock();
 		net = rcu_dereference(wg->creating_net);
@@ -530,8 +549,37 @@
 	}
 
 	if (info->attrs[WGDEVICE_A_LISTEN_PORT]) {
-		ret = set_port(wg,
-			nla_get_u16(info->attrs[WGDEVICE_A_LISTEN_PORT]));
+		u16 port = nla_get_u16(info->attrs[WGDEVICE_A_LISTEN_PORT]);
+		if (wg->incoming_port != port) {
+			if (!netif_running(wg->dev))
+				wg->incoming_port = port;
+			else{
+				if_set_socket = true;
+				port_new = port;
+			}
+		}
+	}
+
+	if (info->attrs[WGDEVICE_A_BIND_ADDR]) {
+		struct sockaddr *addr = nla_data(info->attrs[WGDEVICE_A_BIND_ADDR]);
+		if (!bind_addr_eq(&wg->bind_addr.addr, addr)) {
+			size_t len = nla_len(info->attrs[WGDEVICE_A_BIND_ADDR]);
+			if ((addr->sa_family == AF_INET && len == sizeof(struct sockaddr_in)) ||
+				((addr->sa_family == AF_INET6 || addr->sa_family == AF_UNSPEC) && len == sizeof(struct sockaddr_in6))) {
+					if (!netif_running(wg->dev)){
+						memcpy(&wg->bind_addr.addr, addr, len);
+					} else {
+						if_set_socket=true;
+						memcpy(&bind_addr_new, addr, len);
+					}
+				}
+			else
+				goto out;
+		}
+	}
+
+	if (if_set_socket) {
+		ret = set_socket(wg, &bind_addr_new, port_new);
 		if (ret)
 			goto out;
 	}
@@ -602,48 +650,28 @@
 	return ret;
 }
 
-#ifndef COMPAT_CANNOT_USE_CONST_GENL_OPS
-static const
-#else
-static
-#endif
-struct genl_ops genl_ops[] = {
+static const struct genl_ops genl_ops[] = {
 	{
 		.cmd = WG_CMD_GET_DEVICE,
-#ifndef COMPAT_CANNOT_USE_NETLINK_START
 		.start = wg_get_device_start,
-#endif
 		.dumpit = wg_get_device_dump,
 		.done = wg_get_device_done,
-#ifdef COMPAT_CANNOT_INDIVIDUAL_NETLINK_OPS_POLICY
-		.policy = device_policy,
-#endif
 		.flags = GENL_UNS_ADMIN_PERM
 	}, {
 		.cmd = WG_CMD_SET_DEVICE,
 		.doit = wg_set_device,
-#ifdef COMPAT_CANNOT_INDIVIDUAL_NETLINK_OPS_POLICY
-		.policy = device_policy,
-#endif
 		.flags = GENL_UNS_ADMIN_PERM
 	}
 };
 
-static struct genl_family genl_family
-#ifndef COMPAT_CANNOT_USE_GENL_NOPS
-__ro_after_init = {
+static struct genl_family genl_family __ro_after_init = {
 	.ops = genl_ops,
 	.n_ops = ARRAY_SIZE(genl_ops),
-#else
-= {
-#endif
 	.name = WG_GENL_NAME,
 	.version = WG_GENL_VERSION,
 	.maxattr = WGDEVICE_A_MAX,
 	.module = THIS_MODULE,
-#ifndef COMPAT_CANNOT_INDIVIDUAL_NETLINK_OPS_POLICY
 	.policy = device_policy,
-#endif
 	.netnsok = true
 };
 
diff -Nur a/src/socket.c b/src/socket.c
--- a/src/socket.c	2020-07-13 19:24:22.600618782 +0800
+++ b/src/socket.c	2020-07-13 19:40:09.554727916 +0800
@@ -345,7 +345,7 @@
 	sk_set_memalloc(sock->sk);
 }
 
-int wg_socket_init(struct wg_device *wg, u16 port)
+int wg_socket_init(struct wg_device *wg, struct addr_struct *bind_addr, u16 port)
 {
 	struct net *net;
 	int ret;
@@ -366,6 +366,7 @@
 	struct udp_port_cfg port6 = {
 		.family = AF_INET6,
 		.local_ip6 = IN6ADDR_ANY_INIT,
+		.local_udp_port = htons(port),
 		.use_udp6_tx_checksums = true,
 		.use_udp6_rx_checksums = true,
 		.ipv6_v6only = true
@@ -383,20 +384,23 @@
 retry:
 #endif
 
-	ret = udp_sock_create(net, &port4, &new4);
-	if (ret < 0) {
-		pr_err("%s: Could not create IPv4 socket\n", wg->dev->name);
-		goto out;
+	if (bind_addr->addr.sa_family == AF_INET || bind_addr->addr.sa_family == AF_UNSPEC) {
+		if(bind_addr->addr.sa_family == AF_INET) port4.local_ip = bind_addr->addr4.sin_addr;
+		ret = udp_sock_create(net, &port4, &new4);
+		if (ret < 0) {
+			pr_err("%s: Could not create IPv4 socket\n", wg->dev->name);
+			goto out;
+		}
+		set_sock_opts(new4);
+		setup_udp_tunnel_sock(net, new4, &cfg);
 	}
-	set_sock_opts(new4);
-	setup_udp_tunnel_sock(net, new4, &cfg);
 
 #if IS_ENABLED(CONFIG_IPV6)
-	if (ipv6_mod_enabled()) {
-		port6.local_udp_port = inet_sk(new4->sk)->inet_sport;
+	if (ipv6_mod_enabled() && (bind_addr->addr.sa_family == AF_INET6 || bind_addr->addr.sa_family == AF_UNSPEC)) {
+		if(bind_addr->addr.sa_family == AF_INET6) port6.local_ip6 = bind_addr->addr6.sin6_addr;
 		ret = udp_sock_create(net, &port6, &new6);
 		if (ret < 0) {
-			udp_tunnel_sock_release(new4);
+			if(new4) udp_tunnel_sock_release(new4);
 			if (ret == -EADDRINUSE && !port && retries++ < 100)
 				goto retry;
 			pr_err("%s: Could not create IPv6 socket\n",
@@ -408,7 +412,7 @@
 	}
 #endif
 
-	wg_socket_reinit(wg, new4->sk, new6 ? new6->sk : NULL);
+	wg_socket_reinit(wg, new4 ? new4->sk : NULL, new6 ? new6->sk : NULL);
 	ret = 0;
 out:
 	put_net(net);
@@ -427,8 +431,16 @@
 				lockdep_is_held(&wg->socket_update_lock));
 	rcu_assign_pointer(wg->sock4, new4);
 	rcu_assign_pointer(wg->sock6, new6);
-	if (new4)
+
+	if(new4) {
 		wg->incoming_port = ntohs(inet_sk(new4)->inet_sport);
+		wg->bind_addr.addr4.sin_addr.s_addr = inet_sk(new4)->inet_saddr;
+		wg->bind_addr.addr.sa_family = new6 ? AF_UNSPEC : AF_INET;
+	} else if (new6) {
+		wg->incoming_port = ntohs(inet_sk(new6)->inet_sport);
+		memcpy(&wg->bind_addr.addr6.sin6_addr, &inet6_sk(new6)->saddr, sizeof(struct in6_addr));
+		wg->bind_addr.addr.sa_family = AF_INET6;
+	}
 	mutex_unlock(&wg->socket_update_lock);
 	synchronize_rcu();
 	sock_free(old4);
diff -Nur a/src/socket.h b/src/socket.h
--- a/src/socket.h	2020-07-13 19:24:22.600618782 +0800
+++ b/src/socket.h	2020-07-13 19:40:12.614728269 +0800
@@ -11,7 +11,7 @@
 #include <linux/if_vlan.h>
 #include <linux/if_ether.h>
 
-int wg_socket_init(struct wg_device *wg, u16 port);
+int wg_socket_init(struct wg_device *wg, struct addr_struct *bind_addr, u16 port);
 void wg_socket_reinit(struct wg_device *wg, struct sock *new4,
 		      struct sock *new6);
 int wg_socket_send_buffer_to_peer(struct wg_peer *peer, void *data,
diff -Nur a/src/uapi/wireguard.h b/src/uapi/wireguard.h
--- a/src/uapi/wireguard.h	2020-07-13 19:24:22.601618783 +0800
+++ b/src/uapi/wireguard.h	2020-07-13 19:40:47.482732287 +0800
@@ -155,6 +155,7 @@
 	WGDEVICE_A_PUBLIC_KEY,
 	WGDEVICE_A_FLAGS,
 	WGDEVICE_A_LISTEN_PORT,
+	WGDEVICE_A_BIND_ADDR,
 	WGDEVICE_A_FWMARK,
 	WGDEVICE_A_PEERS,
 	__WGDEVICE_A_LAST
